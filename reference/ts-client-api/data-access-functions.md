# Data access functions

This section details each data access method available for [entity
route](./client-api-basics#entity-route-objects) and [instance
route](./client-api-basics#instance-route-objects) objects generated for the
client API for each CRUD route.

The code examples on this page assume the following backend entity and route:

```ts title="backend/models/BlogPost.ts"
export class BlogPost extends ChiselEntity {
    author: string = "Anonymous"
    content: string
    publishedAt: number
    hidden: boolean
}
```

```ts title="backend/routes/posts.ts"
import { BlogPost } from "../models/BlogPost.ts"

export default BlogPost.crud()
```

And a `chiselClient` object previously created on the frontend:

```ts
const chiselClient = createChiselClient({
    serverUrl: "[BACKEND-URL]"
})
```

Some general attributes of the data access functions described below:

- The generic type `E` is used below to indicate where an entity type is
  required.
- Functions accept either a parameter or object property called `headers` of
  type `Headers | Record<string, string>` to specify additional HTTP headers to
  send with the request. These headers are combined with (and override) those
  specified during [initialization](./client-api-basics#initialization). See
  external documentation for [Headers] and [Record].
- The type `WithoutId<E>` is used to specify a new entity instance without the
  `id` string property, as that string is generated by ChiselStrike.
- Some functions that allow filtering accept a [`FilterExpr`](#filterexpre)
  object that allows for the composition of complex queries that work
  identically to the [Filter expression objects] in the TypeScript API for use
  in [routes](../routing/). 

## Entity route data access functions

### Entity `delete()`

Signature:

```ts
delete(
    filter: FilterExpr<E>,
    headers?: Headers | Record<string, string>,
): Promise<void>
```

`delete()` deletes entity instances that match the provided filter. The first
argument [FilterExpr](#filterexpre) can be empty to indicate all instances.

To delete all BlogPost instances where the author property is "Anonymous":

```ts
await chiselClient.posts.delete({
    author: "Anonymous"
})
```

### Entity `get()`

Signature:

```ts
get(
    params: GetParams<E>
): Promise<GetResponse<E>>
```

`get()` performs a query with pagination against an entity, returning 0 or more
instances. The [GetParams](#getparamse) argument specifies filtering and
pagination for the query.

To query for all BlogPost instances where the author property is "Anonymous",
consuming all pages of results, and logging the ID of each instance:

```ts
const response: GetResponse<BlogPost> =
    await chiselClient.posts.get({
        filter: {
            author: "Anonymous"
        }
    })

for (;;) {
    for (const post of response.results) {
        console.log(post.id)
    }
    if (response.nextPage !== undefined) {
        response = await response.nextPage()
    } else {
        break  // no more pages, stop the loop
    }
}
```

See [`GetResponse`](#getresponsee) below for more information about handling
query results.

To get query results at once in a single array, use
[`getAll()`](#entity-getall). To get query results using [async iteration], use
[`getIter()`](#entity-getiter).

### Entity `getAll()`

Signature:

```ts
getAll(
    params?: GetAllParams<E>
): Promise<E[]>
```

`getAll()` performs a query against an entity, returning all matching instances
in an array. The [GetAllParams](#getallparamse) argument specifies filtering and
limits for the query.

To query for all BlogPost instances:

```ts
const allPosts: BlogPost[] = await chiselClient.posts.getAll()
```

See [`GetAllParams`](#getallparamse) below for more information about filtering
and limiting query results. 

:::warning

`getAll()` should only be used for query results that are known to be limited in
size. If the number of results is very large, this could cause problems with
memory consumption. If you are unsure about the size of the result, consider
using `getIter()` instead, which internally paginates the results during async
iteration to minimize memory.

:::

To get query results with pagination, use [`get()`](#get). To get query results
using [async iteration], use [`getIter()`](#getiter)

### Entity `getIter()`

Signature:

```ts
getIter(
    params?: GetParams<E>
): AsyncIterable<E>
```

`getIter()` performs a query with automatic pagination against an entity,
returning 0 or more instances. The [GetParams](#getparamse) argument specifies
filtering and pagination for the query.

The difference between `getIter()` and `get()` is that the former handles
pagination internally as the returned iterator handles results, so you get the
benefit on reduced memory usage (compared to `getAll()`) but with simpler code
(compared to `get()`).

To query for all BlogPost instances where the author property is "Anonymous" and
log all of their IDs:

```ts
const iter: AsyncIterable<BlogPost> =
    chiselClient.posts.getIter({
        filter: {
            author: "Anonymous"
        }
    })

for await (const post of iter) {
    console.log(post.id)
}
```

To get query results at once in a single array, use
[`getAll()`](#entity-getall). To get query results with manual pagination, use
[`get()`](#entity-get).

### Entity `post()`

Signature:

```ts
post(
    entity: WithoutId<E>,
    headers?: Headers | Record<string, string>,
): Promise<E>
```

`post()` adds a new entity instance with a randomly generated unique ID.

To add a new BlogPost instance and log its newly generated ID:

```ts
const post: BlogPost = await chiselClient.posts.post({
    author: "Me",
    content: "...",
    publishedAt: 999,
    hidden: false,
})

console.log(post.id)
```

## Instance route functions

### Instance `delete()`

Signature:

```ts
delete(
    headers?: Headers | Record<string, string>
): Promise<void>
```

`delete()` deletes the instance.

To delete a specific entity instance:

```ts
await chiselClient.posts.id("[YOUR-ID]").delete()
```

### Instance `get()`

Signature:

```ts
get(
    headers?: Headers | Record<string, string>
): Promise<E>
```

`get()` returns the instance.

To get a specific entity instance:

```ts
const post: BlogPost = await chiselClient.posts.id("[YOUR-ID]").get()
```

### Instance `patch()`

```ts
patch(
    entity: Partial<E>,
    headers?: Headers | Record<string, string>,
): Promise<E>
```

`patch()` performs a partial update of the instance.

To update a field of a specific entity instance:

```ts
const post: BlogPost = await chiselClient.posts.id("[YOUR-ID]").patch({
    author: "Me"
})
```

### Instance `put()`

```ts
put(
    entity: WithoutId<E>,
    headers?: Headers | Record<string, string>,
): Promise<E>
```

`put()` performs a full overwrite of the instance.

To overwrite the contents of a specific entity instance:

```ts
const post: BlogPost = await chiselClient.posts.id("[YOUR-ID]").put({
    author: "Me",
    content: "...",
    publishedAt: 999,
    hidden: false,
})
```

## Utility types

### `GetAllParams<E>`

Type:

```ts
export type GetAllParams<E> = {
    limit?: number;
    offset?: number;
    filter?: FilterExpr<E>;
    headers?: Headers | Record<string, string>;
};
```

A `GetAllParams` object is accepted as an argument for [`getAll()`](#getall). It
has properties that enable filtering and adjusting the window of query results.
All of the properties are optional. If all are left empty, then the query
defaults to requesting all entity instances.

| Property | Description |
| --- | --- |
| limit | The maximum number of results to fetch for the current query |
| offset | The number of instances to skip in total set of query results |
| filter | A [`FilterExpr`](#filterexpre) that specifies which instances to match |
| headers | Additional HTTP headers to provide with the query |


### `GetParams<E>`

Type:

```ts
export type GetParams<E> = {
    pageSize?: number;
    offset?: number;
    filter?: FilterExpr<E>;
    headers?: Headers | Record<string, string>;
};
```

A `GetParams` object is accepted as an argument for [`get()`](#get) and
[`getIter()`](#getiter). It has properties that enable filtering and pagination
of query results. All of the properties are optional. If all are left empty,
then the query defaults to requesting all entity instances.

| Property | Description |
| --- | --- |
| pageSize | The maximum number of results to fetch per page for the current query |
| offset | The number of instances to skip in total set of query results |
| filter | A [`FilterExpr`](#filterexpre) that specifies which instances to match |
| headers | Additional HTTP headers to provide with the query |

### `GetResponse<E>`

Type:

```ts
export type GetResponse<E> = {
    nextPage?: () => Promise<GetResponse<E>>;
    nextPageUrl?: string;
    prevPage?: () => Promise<GetResponse<E>>;
    prevPageUrl?: string;
    results: E[];
};
```

A `GetResponse` object is returned by [get()](#get) to describe the results of a
query. It has properties that allow for easy pagination of queries that were
configured with a [GetParams](#getparamse) object.

| Property | Description |
| --- | --- |
| results | An array of results for the page of data requested |
| nextPage | A function that returns a promise containing the next page of results |
| nextPageUrl | A URL for getting the next page of results using the underlying REST API (it is preferred to use `nextPage` instead) |
| prevPage | A function that returns a promise containing the prior page of results |
| prevPageUrl | A URL for getting the next page of results using the underlying REST API (it is preferred to use `prevPage` instead) |

### `FilterExpr<E>`

Types:

```ts
export type FilterExpr<E> = {
    "$and"?: FilterExpr<E>[];
    "$or"?: FilterExpr<E>[];
    "$not"?: FilterExpr<E>;
} & { [key in keyof Partial<E>]: FieldFilter };

export type FieldFilter = PrimitiveValue | {
    ComparisonOperator: PrimitiveValue;
} | {
    [key: string]: FieldFilter;
};

export type PrimitiveValue = string | number | boolean | null | undefined;
export type EntityValue = PrimitiveValue | { [key: string]: EntityValue };

export type ComparisonOperator =
    | "$eq"
    | "$gt"
    | "$gte"
    | "$lt"
    | "$lte"
    | "$ne";
```

Functions that allow filtering on the set of entities accept a `FilterExpr`
object to limit the entities returned or affected by the function. Filter
expressions make it possible to compose complex queries using logical AND, OR,
and NOT operators, along with range and equality comparators. These filter
expressions work identically to the [Filter expression objects] in the
TypeScript API for use with [routes](../routing/).

For example, to get all BlogPost entity instances where author is "Anonymous" or
the publish date is greater than 999:

```ts
const filteredPosts: BlogPost[] =
    await chiselClient.posts.getAll({
        filter: {
            $or: [
                { name: "Anonymous" },
                { publishedAt: { $gt: 999 } },
            ]
        }
    })
```

### `WithoutId<E>`

`WithoutId<E>` is present in the generated client API to provide a way for code
to specify the contents of an entity without the `id` property, since it is
randomly generated by ChiselStrike. This is used for both
[`post()`](#entity-post) and [`put()`](#instance-put) methods that require an
entire entity definition to create or overwrite.


[Headers]: https://developer.mozilla.org/en-US/docs/Web/API/Headers
[Record]: https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type
[async iteration]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration
[Filter expression objects]: ../entity-ts-api/matching-entities#filter-expression
